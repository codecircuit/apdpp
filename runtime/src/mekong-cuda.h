//
// PURPOSE OF THIS FILE: This is the only file where we use cuda functions.
//                       The reason for this is, that we want to be flexible
//                       between cuda or opencl
//

#ifndef MEKONG_CUDA_H
#define MEKONG_CUDA_H

#include <array>
#include "cuda.h"

namespace Mekong {

using namespace std;

typedef CUresult MErawresult;
typedef CUdevice MEdevice;
typedef CUmodule MEmodule;
typedef CUcontext MEcontext;
typedef CUfunction MEfunction;
typedef CUdeviceptr MEdeviceptr;
typedef CUstream MEstream;

//! This class simplifies error propagation. You can call
//! any cuda function which returns a CUresult. Moreover
//! the class saves always the first error if you use
//! operator&=, e.g.
//!
//! MEresult me_res = someCudaFunction(); // e.g. returns a success
//! me_res &= otherCudaFunction(); // e.g. returns no success
//! me_res &= nextCudaFunction(); // e.g. returns no success
//! 
//! me_res will now hold the error generated by otherCudaFunction()
class MEresult {
	public:
		MEresult();
		MEresult(MErawresult res);
		MEresult(const MEresult& other);

		bool isSuccess() const;
		MErawresult getRaw() const;

		//! same as 'result = result && other'. Returns not a succes if at least one is not a success. 
		MEresult& operator&=(const MEresult& other);

	private:
		MErawresult res_;

};

MEresult operator&&(const MEresult& a, const MEresult& b);
MEresult meInit(unsigned flags);
MEresult meDeviceGetCount(int* count);
MEresult meDeviceGet(MEdevice* device, int ordinal);
MEresult meDeviceComputeCapability(int* major, int* minor, MEdevice dev);
MEresult meCtxCreate(MEcontext* pctx, unsigned int flags, MEdevice dev);
MEresult meCtxSynchronize();
MEresult meCtxPushCurrent(MEcontext ctx);
MEresult meCtxDestroy(MEcontext ctx);
MEresult meCtxPopCurrent(MEcontext* ctx);
MEresult meModuleLoad(MEmodule* module, const char* fname);
MEresult meModuleGetFunction(MEfunction* hfunc, MEmodule hmod, const char* name);
MEresult meMemAlloc(MEdeviceptr* dptr, size_t size);
MEresult meMemcpyHtoD(MEdeviceptr dst, const void* src, size_t size);
MEresult meMemcpyDtoH(void* dst, MEdeviceptr src, size_t size);
MEresult meMemcpyDtoD(MEdeviceptr dst, MEdeviceptr src, size_t size);
MEresult meMemcpyHtoDAsync(MEdeviceptr dst, const void* src, size_t size, MEstream hStream);
MEresult meMemcpyDtoHAsync(void* dst, MEdeviceptr src, size_t size, MEstream hStream);
MEresult meMemcpyDtoDAsync(MEdeviceptr dst, MEdeviceptr src, size_t size, MEstream hStream);
MEresult meMemFree(MEdeviceptr dptr);
MEresult meLaunchKernel(MEfunction f,
						unsigned gridDimX,
						unsigned gridDimY,
						unsigned gridDimZ,
						unsigned blockDimX,
						unsigned blockDimY,
						unsigned blockDimZ,
						unsigned sharedMemBytes,
						MEstream hStream,
						void** kernelArgs,
						void** extra);
array<unsigned, 3> meGetGridLimits(MEdevice dev);
array<unsigned, 3> meGetBlockLimits(MEdevice dev);
size_t meGetThreadsPerBlockLimit(MEdevice dev);
size_t meShMemPerBlockLimit(MEdevice dev);

} // namespace end

#endif
